/* automatically generated by rust-bindgen 0.68.1 */

extern "C" {
    #[doc = " Version string of linked libheif library."]
    pub fn heif_get_version() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Numeric version of linked libheif library, encoded as BCD 0xHHMMLL00 = HH.MM.LL.\n For example: 0x02143000 is version 2.14.30"]
    pub fn heif_get_version_number() -> u32;
}
extern "C" {
    #[doc = " Numeric part \"HH\" from above. Returned as a decimal number (not BCD)."]
    pub fn heif_get_version_number_major() -> libc::c_int;
}
extern "C" {
    #[doc = " Numeric part \"MM\" from above. Returned as a decimal number (not BCD)."]
    pub fn heif_get_version_number_minor() -> libc::c_int;
}
extern "C" {
    #[doc = " Numeric part \"LL\" from above. Returned as a decimal number (not BCD)."]
    pub fn heif_get_version_number_maintenance() -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_image_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_image {
    _unused: [u8; 0],
}
#[doc = " Everything ok, no error occurred."]
pub const heif_error_code_heif_error_Ok: heif_error_code = 0;
#[doc = " Input file does not exist."]
pub const heif_error_code_heif_error_Input_does_not_exist: heif_error_code = 1;
#[doc = " Error in input file. Corrupted or invalid content."]
pub const heif_error_code_heif_error_Invalid_input: heif_error_code = 2;
#[doc = " Input file type is not supported."]
pub const heif_error_code_heif_error_Unsupported_filetype: heif_error_code = 3;
#[doc = " Image requires an unsupported decoder feature."]
pub const heif_error_code_heif_error_Unsupported_feature: heif_error_code = 4;
#[doc = " Library API has been used in an invalid way."]
pub const heif_error_code_heif_error_Usage_error: heif_error_code = 5;
#[doc = " Could not allocate enough memory."]
pub const heif_error_code_heif_error_Memory_allocation_error: heif_error_code = 6;
#[doc = " The decoder plugin generated an error"]
pub const heif_error_code_heif_error_Decoder_plugin_error: heif_error_code = 7;
#[doc = " The encoder plugin generated an error"]
pub const heif_error_code_heif_error_Encoder_plugin_error: heif_error_code = 8;
#[doc = " Error during encoding or when writing to the output"]
pub const heif_error_code_heif_error_Encoding_error: heif_error_code = 9;
#[doc = " Application has asked for a color profile type that does not exist"]
pub const heif_error_code_heif_error_Color_profile_does_not_exist: heif_error_code = 10;
#[doc = " Error loading a dynamic plugin"]
pub const heif_error_code_heif_error_Plugin_loading_error: heif_error_code = 11;
pub type heif_error_code = libc::c_uint;
#[doc = " no further information available"]
pub const heif_suberror_code_heif_suberror_Unspecified: heif_suberror_code = 0;
#[doc = " End of data reached unexpectedly."]
pub const heif_suberror_code_heif_suberror_End_of_data: heif_suberror_code = 100;
#[doc = " Size of box (defined in header) is wrong"]
pub const heif_suberror_code_heif_suberror_Invalid_box_size: heif_suberror_code = 101;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_ftyp_box: heif_suberror_code = 102;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_idat_box: heif_suberror_code = 103;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_meta_box: heif_suberror_code = 104;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_hdlr_box: heif_suberror_code = 105;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_hvcC_box: heif_suberror_code = 106;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_pitm_box: heif_suberror_code = 107;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_ipco_box: heif_suberror_code = 108;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_ipma_box: heif_suberror_code = 109;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_iloc_box: heif_suberror_code = 110;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_iinf_box: heif_suberror_code = 111;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_iprp_box: heif_suberror_code = 112;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_iref_box: heif_suberror_code = 113;
#[doc = " Mandatory 'ftyp' box is missing"]
pub const heif_suberror_code_heif_suberror_No_pict_handler: heif_suberror_code = 114;
#[doc = " An item property referenced in the 'ipma' box is not existing in the 'ipco' container."]
pub const heif_suberror_code_heif_suberror_Ipma_box_references_nonexisting_property:
    heif_suberror_code = 115;
#[doc = " No properties have been assigned to an item."]
pub const heif_suberror_code_heif_suberror_No_properties_assigned_to_item: heif_suberror_code = 116;
#[doc = " Image has no (compressed) data"]
pub const heif_suberror_code_heif_suberror_No_item_data: heif_suberror_code = 117;
#[doc = " Invalid specification of image grid (tiled image)"]
pub const heif_suberror_code_heif_suberror_Invalid_grid_data: heif_suberror_code = 118;
#[doc = " Tile-images in a grid image are missing"]
pub const heif_suberror_code_heif_suberror_Missing_grid_images: heif_suberror_code = 119;
#[doc = " Tile-images in a grid image are missing"]
pub const heif_suberror_code_heif_suberror_Invalid_clean_aperture: heif_suberror_code = 120;
#[doc = " Invalid specification of overlay image"]
pub const heif_suberror_code_heif_suberror_Invalid_overlay_data: heif_suberror_code = 121;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Overlay_image_outside_of_canvas: heif_suberror_code =
    122;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Auxiliary_image_type_unspecified: heif_suberror_code =
    123;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_No_or_invalid_primary_item: heif_suberror_code = 124;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_No_infe_box: heif_suberror_code = 125;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Unknown_color_profile_type: heif_suberror_code = 126;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Wrong_tile_image_chroma_format: heif_suberror_code = 127;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Invalid_fractional_number: heif_suberror_code = 128;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Invalid_image_size: heif_suberror_code = 129;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Invalid_pixi_box: heif_suberror_code = 130;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_No_av1C_box: heif_suberror_code = 131;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Wrong_tile_image_pixel_depth: heif_suberror_code = 132;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Unknown_NCLX_color_primaries: heif_suberror_code = 133;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Unknown_NCLX_transfer_characteristics:
    heif_suberror_code = 134;
#[doc = " Overlay image completely outside of visible canvas area"]
pub const heif_suberror_code_heif_suberror_Unknown_NCLX_matrix_coefficients: heif_suberror_code =
    135;
#[doc = " Invalid specification of region item"]
pub const heif_suberror_code_heif_suberror_Invalid_region_data: heif_suberror_code = 136;
#[doc = " A security limit preventing unreasonable memory allocations was exceeded by the input file.\n Please check whether the file is valid. If it is, contact us so that we could increase the\n security limits further."]
pub const heif_suberror_code_heif_suberror_Security_limit_exceeded: heif_suberror_code = 1000;
#[doc = " also used for Invalid_input"]
pub const heif_suberror_code_heif_suberror_Nonexisting_item_referenced: heif_suberror_code = 2000;
#[doc = " An API argument was given a NULL pointer, which is not allowed for that function."]
pub const heif_suberror_code_heif_suberror_Null_pointer_argument: heif_suberror_code = 2001;
#[doc = " Image channel referenced that does not exist in the image"]
pub const heif_suberror_code_heif_suberror_Nonexisting_image_channel_referenced:
    heif_suberror_code = 2002;
#[doc = " The version of the passed plugin is not supported."]
pub const heif_suberror_code_heif_suberror_Unsupported_plugin_version: heif_suberror_code = 2003;
#[doc = " The version of the passed writer is not supported."]
pub const heif_suberror_code_heif_suberror_Unsupported_writer_version: heif_suberror_code = 2004;
#[doc = " The given (encoder) parameter name does not exist."]
pub const heif_suberror_code_heif_suberror_Unsupported_parameter: heif_suberror_code = 2005;
#[doc = " The value for the given parameter is not in the valid range."]
pub const heif_suberror_code_heif_suberror_Invalid_parameter_value: heif_suberror_code = 2006;
#[doc = " Error in property specification"]
pub const heif_suberror_code_heif_suberror_Invalid_property: heif_suberror_code = 2007;
#[doc = " Image reference cycle found in iref"]
pub const heif_suberror_code_heif_suberror_Item_reference_cycle: heif_suberror_code = 2008;
#[doc = " Image was coded with an unsupported compression method."]
pub const heif_suberror_code_heif_suberror_Unsupported_codec: heif_suberror_code = 3000;
#[doc = " Image is specified in an unknown way, e.g. as tiled grid image (which is supported)"]
pub const heif_suberror_code_heif_suberror_Unsupported_image_type: heif_suberror_code = 3001;
#[doc = " Image is specified in an unknown way, e.g. as tiled grid image (which is supported)"]
pub const heif_suberror_code_heif_suberror_Unsupported_data_version: heif_suberror_code = 3002;
#[doc = " The conversion of the source image to the requested chroma / colorspace is not supported."]
pub const heif_suberror_code_heif_suberror_Unsupported_color_conversion: heif_suberror_code = 3003;
#[doc = " The conversion of the source image to the requested chroma / colorspace is not supported."]
pub const heif_suberror_code_heif_suberror_Unsupported_item_construction_method:
    heif_suberror_code = 3004;
#[doc = " The conversion of the source image to the requested chroma / colorspace is not supported."]
pub const heif_suberror_code_heif_suberror_Unsupported_header_compression_method:
    heif_suberror_code = 3005;
#[doc = " --- Encoder_plugin_error ---"]
pub const heif_suberror_code_heif_suberror_Unsupported_bit_depth: heif_suberror_code = 4000;
#[doc = " --- Encoding_error ---"]
pub const heif_suberror_code_heif_suberror_Cannot_write_output_data: heif_suberror_code = 5000;
#[doc = " --- Encoding_error ---"]
pub const heif_suberror_code_heif_suberror_Encoder_initialization: heif_suberror_code = 5001;
#[doc = " --- Encoding_error ---"]
pub const heif_suberror_code_heif_suberror_Encoder_encoding: heif_suberror_code = 5002;
#[doc = " --- Encoding_error ---"]
pub const heif_suberror_code_heif_suberror_Encoder_cleanup: heif_suberror_code = 5003;
#[doc = " --- Encoding_error ---"]
pub const heif_suberror_code_heif_suberror_Too_many_regions: heif_suberror_code = 5004;
#[doc = " a specific plugin file cannot be loaded"]
pub const heif_suberror_code_heif_suberror_Plugin_loading_error: heif_suberror_code = 6000;
#[doc = " trying to remove a plugin that is not loaded"]
pub const heif_suberror_code_heif_suberror_Plugin_is_not_loaded: heif_suberror_code = 6001;
#[doc = " error while scanning the directory for plugins"]
pub const heif_suberror_code_heif_suberror_Cannot_read_plugin_directory: heif_suberror_code = 6002;
pub type heif_suberror_code = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_error {
    #[doc = " main error category"]
    pub code: heif_error_code,
    #[doc = " more detailed error code"]
    pub subcode: heif_suberror_code,
    #[doc = " textual error message (is always defined, you do not have to check for NULL)"]
    pub message: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_heif_error() {
    const UNINIT: ::std::mem::MaybeUninit<heif_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_error>(),
        16usize,
        concat!("Size of: ", stringify!(heif_error))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_error>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_error),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subcode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_error),
            "::",
            stringify!(subcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_error),
            "::",
            stringify!(message)
        )
    );
}
pub type heif_item_id = u32;
pub type heif_property_id = u32;
#[doc = " You should call heif_init() when you start using libheif and heif_deinit() when you are finished.\n These calls are reference counted. Each call to heif_init() should be matched by one call to heif_deinit().\n For backwards compatibility, it is not really necessary to call heif_init(), but if you don't, the plugins\n registered by default may not be freed correctly.\n However, this should not be mixed, i.e. one part of your program does use heif_init()/heif_deinit() and another doesn't.\n If in doubt, enclose everything with init/deinit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_init_params {
    pub version: libc::c_int,
}
#[test]
fn bindgen_test_layout_heif_init_params() {
    const UNINIT: ::std::mem::MaybeUninit<heif_init_params> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_init_params>(),
        4usize,
        concat!("Size of: ", stringify!(heif_init_params))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_init_params>(),
        4usize,
        concat!("Alignment of ", stringify!(heif_init_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_init_params),
            "::",
            stringify!(version)
        )
    );
}
extern "C" {
    #[doc = " You may pass nullptr to get default parameters. Currently, no parameters are supported."]
    pub fn heif_init(arg1: *mut heif_init_params) -> heif_error;
}
extern "C" {
    pub fn heif_deinit();
}
pub const heif_plugin_type_heif_plugin_type_encoder: heif_plugin_type = 0;
pub const heif_plugin_type_heif_plugin_type_decoder: heif_plugin_type = 1;
#[doc = " --- Plugins are currently only supported on Unix platforms."]
pub type heif_plugin_type = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_plugin_info {
    #[doc = " version of this info struct"]
    pub version: libc::c_int,
    pub type_: heif_plugin_type,
    pub plugin: *const libc::c_void,
    #[doc = " for internal use only"]
    pub internal_handle: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_heif_plugin_info() {
    const UNINIT: ::std::mem::MaybeUninit<heif_plugin_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_plugin_info>(),
        24usize,
        concat!("Size of: ", stringify!(heif_plugin_info))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_plugin_info>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_plugin_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_plugin_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_plugin_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plugin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_plugin_info),
            "::",
            stringify!(plugin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_handle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_plugin_info),
            "::",
            stringify!(internal_handle)
        )
    );
}
extern "C" {
    pub fn heif_load_plugin(
        filename: *const libc::c_char,
        out_plugin: *mut *const heif_plugin_info,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_load_plugins(
        directory: *const libc::c_char,
        out_plugins: *mut *const heif_plugin_info,
        out_nPluginsLoaded: *mut libc::c_int,
        output_array_size: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_unload_plugin(plugin: *const heif_plugin_info) -> heif_error;
}
pub const heif_filetype_result_heif_filetype_no: heif_filetype_result = 0;
#[doc = " it is heif and can be read by libheif"]
pub const heif_filetype_result_heif_filetype_yes_supported: heif_filetype_result = 1;
#[doc = " it is heif, but cannot be read by libheif"]
pub const heif_filetype_result_heif_filetype_yes_unsupported: heif_filetype_result = 2;
#[doc = " not sure whether it is an heif, try detection with more input data"]
pub const heif_filetype_result_heif_filetype_maybe: heif_filetype_result = 3;
#[doc = " ========================= file type check ======================"]
pub type heif_filetype_result = libc::c_uint;
extern "C" {
    #[doc = " input data should be at least 12 bytes"]
    pub fn heif_check_filetype(data: *const u8, len: libc::c_int) -> heif_filetype_result;
}
extern "C" {
    pub fn heif_check_jpeg_filetype(data: *const u8, len: libc::c_int) -> libc::c_int;
}
pub const heif_brand_heif_unknown_brand: heif_brand = 0;
#[doc = " HEIF image with h265"]
pub const heif_brand_heif_heic: heif_brand = 1;
#[doc = " 10bit images, or anything that uses h265 with range extension"]
pub const heif_brand_heif_heix: heif_brand = 2;
#[doc = " brands for image sequences"]
pub const heif_brand_heif_hevc: heif_brand = 3;
#[doc = " brands for image sequences"]
pub const heif_brand_heif_hevx: heif_brand = 4;
#[doc = " multiview"]
pub const heif_brand_heif_heim: heif_brand = 5;
#[doc = " scalable"]
pub const heif_brand_heif_heis: heif_brand = 6;
#[doc = " multiview sequence"]
pub const heif_brand_heif_hevm: heif_brand = 7;
#[doc = " scalable sequence"]
pub const heif_brand_heif_hevs: heif_brand = 8;
#[doc = " image, any coding algorithm"]
pub const heif_brand_heif_mif1: heif_brand = 9;
#[doc = " sequence, any coding algorithm"]
pub const heif_brand_heif_msf1: heif_brand = 10;
#[doc = " HEIF image with AV1"]
pub const heif_brand_heif_avif: heif_brand = 11;
pub const heif_brand_heif_avis: heif_brand = 12;
#[doc = " VVC image"]
pub const heif_brand_heif_vvic: heif_brand = 13;
#[doc = " VVC sequence"]
pub const heif_brand_heif_vvis: heif_brand = 14;
#[doc = " EVC image"]
pub const heif_brand_heif_evbi: heif_brand = 15;
#[doc = " EVC sequence"]
pub const heif_brand_heif_evbs: heif_brand = 16;
#[doc = " DEPRECATED, use heif_brand2 and the heif_brand2_* constants below instead"]
pub type heif_brand = libc::c_uint;
extern "C" {
    #[doc = " input data should be at least 12 bytes\n DEPRECATED, use heif_read_main_brand() instead"]
    pub fn heif_main_brand(data: *const u8, len: libc::c_int) -> heif_brand;
}
pub type heif_brand2 = u32;
extern "C" {
    #[doc = " input data should be at least 12 bytes"]
    pub fn heif_read_main_brand(data: *const u8, len: libc::c_int) -> heif_brand2;
}
extern "C" {
    #[doc = " 'brand_fourcc' must be 4 character long, but need not be 0-terminated"]
    pub fn heif_fourcc_to_brand(brand_fourcc: *const libc::c_char) -> heif_brand2;
}
extern "C" {
    #[doc = " the output buffer must be at least 4 bytes long"]
    pub fn heif_brand_to_fourcc(brand: heif_brand2, out_fourcc: *mut libc::c_char);
}
extern "C" {
    #[doc = " 'brand_fourcc' must be 4 character long, but need not be 0-terminated\n returns 1 if file includes the brand, and 0 if it does not\n returns -1 if the provided data is not sufficient\n            (you should input at least as many bytes as indicated in the first 4 bytes of the file, usually ~50 bytes will do)\n returns -2 on other errors"]
    pub fn heif_has_compatible_brand(
        data: *const u8,
        len: libc::c_int,
        brand_fourcc: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns an array of compatible brands. The array is allocated by this function and has to be freed with 'heif_free_list_of_compatible_brands()'.\n The number of entries is returned in out_size."]
    pub fn heif_list_compatible_brands(
        data: *const u8,
        len: libc::c_int,
        out_brands: *mut *mut heif_brand2,
        out_size: *mut libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_free_list_of_compatible_brands(brands_list: *mut heif_brand2);
}
extern "C" {
    #[doc = " Returns one of these MIME types:\n - image/heic           HEIF file using h265 compression\n - image/heif           HEIF file using any other compression\n - image/heic-sequence  HEIF image sequence using h265 compression\n - image/heif-sequence  HEIF image sequence using any other compression\n - image/avif           AVIF image\n - image/avif-sequence  AVIF sequence\n - image/jpeg    JPEG image\n - image/png     PNG image\n If the format could not be detected, an empty string is returned.\n\n Provide at least 12 bytes of input. With less input, its format might not\n be detected. You may also provide more input to increase detection accuracy.\n\n Note that JPEG and PNG images cannot be decoded by libheif even though the\n formats are detected by this function."]
    pub fn heif_get_file_mime_type(data: *const u8, len: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Allocate a new context for reading HEIF files.\n Has to be freed again with heif_context_free()."]
    pub fn heif_context_alloc() -> *mut heif_context;
}
extern "C" {
    #[doc = " Free a previously allocated HEIF context. You should not free a context twice."]
    pub fn heif_context_free(arg1: *mut heif_context);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_reading_options {
    _unused: [u8; 0],
}
#[doc = " requested size has been reached, we can read until this point"]
pub const heif_reader_grow_status_heif_reader_grow_status_size_reached: heif_reader_grow_status = 0;
#[doc = " size has not been reached yet, but it may still grow further"]
pub const heif_reader_grow_status_heif_reader_grow_status_timeout: heif_reader_grow_status = 1;
#[doc = " size has not been reached and never will. The file has grown to its full size"]
pub const heif_reader_grow_status_heif_reader_grow_status_size_beyond_eof: heif_reader_grow_status =
    2;
pub type heif_reader_grow_status = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_reader {
    #[doc = " API version supported by this reader"]
    pub reader_api_version: libc::c_int,
    #[doc = " --- version 1 functions ---"]
    pub get_position:
        ::std::option::Option<unsafe extern "C" fn(userdata: *mut libc::c_void) -> i64>,
    #[doc = " The functions read(), and seek() return 0 on success.\n Generally, libheif will make sure that we do not read past the file size."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut libc::c_void,
            size: usize,
            userdata: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(position: i64, userdata: *mut libc::c_void) -> libc::c_int,
    >,
    #[doc = " When calling this function, libheif wants to make sure that it can read the file\n up to 'target_size'. This is useful when the file is currently downloaded and may\n grow with time. You may, for example, extract the image sizes even before the actual\n compressed image data has been completely downloaded.\n\n Even if your input files will not grow, you will have to implement at least\n detection whether the target_size is above the (fixed) file length\n (in this case, return 'size_beyond_eof')."]
    pub wait_for_file_size: ::std::option::Option<
        unsafe extern "C" fn(
            target_size: i64,
            userdata: *mut libc::c_void,
        ) -> heif_reader_grow_status,
    >,
}
#[test]
fn bindgen_test_layout_heif_reader() {
    const UNINIT: ::std::mem::MaybeUninit<heif_reader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_reader>(),
        40usize,
        concat!("Size of: ", stringify!(heif_reader))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_reader>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_reader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reader_api_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_reader),
            "::",
            stringify!(reader_api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_reader),
            "::",
            stringify!(get_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_reader),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_reader),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait_for_file_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_reader),
            "::",
            stringify!(wait_for_file_size)
        )
    );
}
extern "C" {
    #[doc = " Read a HEIF file from a named disk file.\n The heif_reading_options should currently be set to NULL."]
    pub fn heif_context_read_from_file(
        arg1: *mut heif_context,
        filename: *const libc::c_char,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Read a HEIF file stored completely in memory.\n The heif_reading_options should currently be set to NULL.\n DEPRECATED: use heif_context_read_from_memory_without_copy() instead."]
    pub fn heif_context_read_from_memory(
        arg1: *mut heif_context,
        mem: *const libc::c_void,
        size: usize,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Same as heif_context_read_from_memory() except that the provided memory is not copied.\n That means, you will have to keep the memory area alive as long as you use the heif_context."]
    pub fn heif_context_read_from_memory_without_copy(
        arg1: *mut heif_context,
        mem: *const libc::c_void,
        size: usize,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_read_from_reader(
        arg1: *mut heif_context,
        reader: *const heif_reader,
        userdata: *mut libc::c_void,
        arg2: *const heif_reading_options,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Number of top-level images in the HEIF file. This does not include the thumbnails or the\n tile images that are composed to an image grid. You can get access to the thumbnails via\n the main image handle."]
    pub fn heif_context_get_number_of_top_level_images(ctx: *mut heif_context) -> libc::c_int;
}
extern "C" {
    pub fn heif_context_is_top_level_image_ID(
        ctx: *mut heif_context,
        id: heif_item_id,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fills in image IDs into the user-supplied int-array 'ID_array', preallocated with 'count' entries.\n Function returns the total number of IDs filled into the array."]
    pub fn heif_context_get_list_of_top_level_image_IDs(
        ctx: *mut heif_context,
        ID_array: *mut heif_item_id,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_context_get_primary_image_ID(
        ctx: *mut heif_context,
        id: *mut heif_item_id,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Get a handle to the primary image of the HEIF file.\n This is the image that should be displayed primarily when there are several images in the file."]
    pub fn heif_context_get_primary_image_handle(
        ctx: *mut heif_context,
        arg1: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Get the handle for a specific top-level image from an image ID."]
    pub fn heif_context_get_image_handle(
        ctx: *mut heif_context,
        id: heif_item_id,
        arg1: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Print information about the boxes of a HEIF file to file descriptor.\n This is for debugging and informational purposes only. You should not rely on\n the output having a specific format. At best, you should not use this at all."]
    pub fn heif_context_debug_dump_boxes_to_file(ctx: *mut heif_context, fd: libc::c_int);
}
extern "C" {
    pub fn heif_context_set_maximum_image_size_limit(
        ctx: *mut heif_context,
        maximum_width: libc::c_int,
    );
}
extern "C" {
    #[doc = " If the maximum threads number is set to 0, the image tiles are decoded in the main thread.\n This is different from setting it to 1, which will generate a single background thread to decode the tiles.\n Note that this setting only affects libheif itself. The codecs itself may still use multi-threaded decoding.\n You can use it, for example, in cases where you are decoding several images in parallel anyway you thus want\n to minimize parallelism in each decoder."]
    pub fn heif_context_set_max_decoding_threads(ctx: *mut heif_context, max_threads: libc::c_int);
}
extern "C" {
    #[doc = " Release image handle."]
    pub fn heif_image_handle_release(arg1: *const heif_image_handle);
}
extern "C" {
    #[doc = " Check whether the given image_handle is the primary image of the file."]
    pub fn heif_image_handle_is_primary_image(handle: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_item_id(handle: *const heif_image_handle) -> heif_item_id;
}
extern "C" {
    #[doc = " Get the resolution of an image."]
    pub fn heif_image_handle_get_width(handle: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_height(handle: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_has_alpha_channel(arg1: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_is_premultiplied_alpha(arg1: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns -1 on error, e.g. if this information is not present in the image."]
    pub fn heif_image_handle_get_luma_bits_per_pixel(arg1: *const heif_image_handle)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Returns -1 on error, e.g. if this information is not present in the image."]
    pub fn heif_image_handle_get_chroma_bits_per_pixel(
        arg1: *const heif_image_handle,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the image width from the 'ispe' box. This is the original image size without\n any transformations applied to it. Do not use this unless you know exactly what\n you are doing."]
    pub fn heif_image_handle_get_ispe_width(handle: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_ispe_height(handle: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    #[doc = " ------------------------- depth images -------------------------"]
    pub fn heif_image_handle_has_depth_image(arg1: *const heif_image_handle) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_number_of_depth_images(
        handle: *const heif_image_handle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_list_of_depth_image_IDs(
        handle: *const heif_image_handle,
        ids: *mut heif_item_id,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_depth_image_handle(
        handle: *const heif_image_handle,
        depth_image_id: heif_item_id,
        out_depth_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
pub const heif_depth_representation_type_heif_depth_representation_type_uniform_inverse_Z:
    heif_depth_representation_type = 0;
pub const heif_depth_representation_type_heif_depth_representation_type_uniform_disparity:
    heif_depth_representation_type = 1;
pub const heif_depth_representation_type_heif_depth_representation_type_uniform_Z:
    heif_depth_representation_type = 2;
pub const heif_depth_representation_type_heif_depth_representation_type_nonuniform_disparity:
    heif_depth_representation_type = 3;
pub type heif_depth_representation_type = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_depth_representation_info {
    pub version: u8,
    #[doc = " version 1 fields"]
    pub has_z_near: u8,
    pub has_z_far: u8,
    pub has_d_min: u8,
    pub has_d_max: u8,
    pub z_near: f64,
    pub z_far: f64,
    pub d_min: f64,
    pub d_max: f64,
    pub depth_representation_type: heif_depth_representation_type,
    pub disparity_reference_view: u32,
    pub depth_nonlinear_representation_model_size: u32,
    pub depth_nonlinear_representation_model: *mut u8,
}
#[test]
fn bindgen_test_layout_heif_depth_representation_info() {
    const UNINIT: ::std::mem::MaybeUninit<heif_depth_representation_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_depth_representation_info>(),
        64usize,
        concat!("Size of: ", stringify!(heif_depth_representation_info))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_depth_representation_info>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_depth_representation_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_z_near) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(has_z_near)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_z_far) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(has_z_far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_d_min) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(has_d_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_d_max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(has_d_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_near) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(z_near)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z_far) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(z_far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_min) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(d_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_max) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(d_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth_representation_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(depth_representation_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disparity_reference_view) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(disparity_reference_view)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).depth_nonlinear_representation_model_size) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(depth_nonlinear_representation_model_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).depth_nonlinear_representation_model) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_depth_representation_info),
            "::",
            stringify!(depth_nonlinear_representation_model)
        )
    );
}
extern "C" {
    pub fn heif_depth_representation_info_free(info: *const heif_depth_representation_info);
}
extern "C" {
    #[doc = " Returns true when there is depth_representation_info available\n Note 1: depth_image_id is currently unused because we support only one depth channel per image, but\n you should still provide the correct ID for future compatibility.\n Note 2: Because of an API bug before v1.11.0, the function also works when 'handle' is the handle of the depth image.\n However, you should pass the handle of the main image. Please adapt your code if needed."]
    pub fn heif_image_handle_get_depth_image_representation_info(
        handle: *const heif_image_handle,
        depth_image_id: heif_item_id,
        out: *mut *const heif_depth_representation_info,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " List the number of thumbnails assigned to this image handle. Usually 0 or 1."]
    pub fn heif_image_handle_get_number_of_thumbnails(
        handle: *const heif_image_handle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_list_of_thumbnail_IDs(
        handle: *const heif_image_handle,
        ids: *mut heif_item_id,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the image handle of a thumbnail image."]
    pub fn heif_image_handle_get_thumbnail(
        main_image_handle: *const heif_image_handle,
        thumbnail_id: heif_item_id,
        out_thumbnail_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    #[doc = " List the number of auxiliary images assigned to this image handle."]
    pub fn heif_image_handle_get_number_of_auxiliary_images(
        handle: *const heif_image_handle,
        aux_filter: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_handle_get_list_of_auxiliary_image_IDs(
        handle: *const heif_image_handle,
        aux_filter: libc::c_int,
        ids: *mut heif_item_id,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " You are responsible to deallocate the returned buffer with heif_image_handle_release_auxiliary_type()."]
    pub fn heif_image_handle_get_auxiliary_type(
        handle: *const heif_image_handle,
        out_type: *mut *const libc::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_handle_release_auxiliary_type(
        handle: *const heif_image_handle,
        out_type: *mut *const libc::c_char,
    );
}
extern "C" {
    #[doc = " DEPRECATED (because typo in function name). Use heif_image_handle_release_auxiliary_type() instead."]
    pub fn heif_image_handle_free_auxiliary_types(
        handle: *const heif_image_handle,
        out_type: *mut *const libc::c_char,
    );
}
extern "C" {
    #[doc = " Get the image handle of an auxiliary image."]
    pub fn heif_image_handle_get_auxiliary_image_handle(
        main_image_handle: *const heif_image_handle,
        auxiliary_id: heif_item_id,
        out_auxiliary_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    #[doc = " How many metadata blocks are attached to an image. If you only want to get EXIF data,\n set the type_filter to \"Exif\". Otherwise, set the type_filter to NULL."]
    pub fn heif_image_handle_get_number_of_metadata_blocks(
        handle: *const heif_image_handle,
        type_filter: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " 'type_filter' can be used to get only metadata of specific types, like \"Exif\".\n If 'type_filter' is NULL, it will return all types of metadata IDs."]
    pub fn heif_image_handle_get_list_of_metadata_block_IDs(
        handle: *const heif_image_handle,
        type_filter: *const libc::c_char,
        ids: *mut heif_item_id,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a string indicating the type of the metadata, as specified in the HEIF file.\n Exif data will have the type string \"Exif\".\n This string will be valid until the next call to a libheif function.\n You do not have to free this string."]
    pub fn heif_image_handle_get_metadata_type(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " For EXIF, the content type is empty.\n For XMP, the content type is \"application/rdf+xml\"."]
    pub fn heif_image_handle_get_metadata_content_type(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the size of the raw metadata, as stored in the HEIF file."]
    pub fn heif_image_handle_get_metadata_size(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
    ) -> usize;
}
extern "C" {
    #[doc = " 'out_data' must point to a memory area of the size reported by heif_image_handle_get_metadata_size().\n The data is returned exactly as stored in the HEIF file.\n For Exif data, you probably have to skip the first four bytes of the data, since they\n indicate the offset to the start of the TIFF header of the Exif data."]
    pub fn heif_image_handle_get_metadata(
        handle: *const heif_image_handle,
        metadata_id: heif_item_id,
        out_data: *mut libc::c_void,
    ) -> heif_error;
}
pub const heif_color_profile_type_heif_color_profile_type_not_present: heif_color_profile_type = 0;
pub const heif_color_profile_type_heif_color_profile_type_nclx: heif_color_profile_type =
    1852009592;
pub const heif_color_profile_type_heif_color_profile_type_rICC: heif_color_profile_type =
    1917403971;
pub const heif_color_profile_type_heif_color_profile_type_prof: heif_color_profile_type =
    1886547814;
#[doc = " ------------------------- color profiles -------------------------"]
pub type heif_color_profile_type = libc::c_uint;
extern "C" {
    #[doc = " Returns 'heif_color_profile_type_not_present' if there is no color profile.\n If there is an ICC profile and an NCLX profile, the ICC profile is returned.\n TODO: we need a new API for this function as images can contain both NCLX and ICC at the same time.\n       However, you can still use heif_image_handle_get_raw_color_profile() and\n       heif_image_handle_get_nclx_color_profile() to access both profiles."]
    pub fn heif_image_handle_get_color_profile_type(
        handle: *const heif_image_handle,
    ) -> heif_color_profile_type;
}
extern "C" {
    pub fn heif_image_handle_get_raw_color_profile_size(handle: *const heif_image_handle) -> usize;
}
extern "C" {
    #[doc = " Returns 'heif_error_Color_profile_does_not_exist' when there is no ICC profile."]
    pub fn heif_image_handle_get_raw_color_profile(
        handle: *const heif_image_handle,
        out_data: *mut libc::c_void,
    ) -> heif_error;
}
#[doc = " g=0.3;0.6, b=0.15;0.06, r=0.64;0.33, w=0.3127,0.3290"]
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_709_5: heif_color_primaries = 1;
pub const heif_color_primaries_heif_color_primaries_unspecified: heif_color_primaries = 2;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_470_6_System_M: heif_color_primaries =
    4;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_470_6_System_B_G:
    heif_color_primaries = 5;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_601_6: heif_color_primaries = 6;
pub const heif_color_primaries_heif_color_primaries_SMPTE_240M: heif_color_primaries = 7;
pub const heif_color_primaries_heif_color_primaries_generic_film: heif_color_primaries = 8;
pub const heif_color_primaries_heif_color_primaries_ITU_R_BT_2020_2_and_2100_0:
    heif_color_primaries = 9;
pub const heif_color_primaries_heif_color_primaries_SMPTE_ST_428_1: heif_color_primaries = 10;
pub const heif_color_primaries_heif_color_primaries_SMPTE_RP_431_2: heif_color_primaries = 11;
pub const heif_color_primaries_heif_color_primaries_SMPTE_EG_432_1: heif_color_primaries = 12;
pub const heif_color_primaries_heif_color_primaries_EBU_Tech_3213_E: heif_color_primaries = 22;
pub type heif_color_primaries = libc::c_uint;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_709_5:
    heif_transfer_characteristics = 1;
pub const heif_transfer_characteristics_heif_transfer_characteristic_unspecified:
    heif_transfer_characteristics = 2;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_470_6_System_M:
    heif_transfer_characteristics = 4;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_470_6_System_B_G:
    heif_transfer_characteristics = 5;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_601_6:
    heif_transfer_characteristics = 6;
pub const heif_transfer_characteristics_heif_transfer_characteristic_SMPTE_240M:
    heif_transfer_characteristics = 7;
pub const heif_transfer_characteristics_heif_transfer_characteristic_linear:
    heif_transfer_characteristics = 8;
pub const heif_transfer_characteristics_heif_transfer_characteristic_logarithmic_100:
    heif_transfer_characteristics = 9;
pub const heif_transfer_characteristics_heif_transfer_characteristic_logarithmic_100_sqrt10:
    heif_transfer_characteristics = 10;
pub const heif_transfer_characteristics_heif_transfer_characteristic_IEC_61966_2_4:
    heif_transfer_characteristics = 11;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_1361:
    heif_transfer_characteristics = 12;
pub const heif_transfer_characteristics_heif_transfer_characteristic_IEC_61966_2_1:
    heif_transfer_characteristics = 13;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2020_2_10bit:
    heif_transfer_characteristics = 14;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2020_2_12bit:
    heif_transfer_characteristics = 15;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2100_0_PQ:
    heif_transfer_characteristics = 16;
pub const heif_transfer_characteristics_heif_transfer_characteristic_SMPTE_ST_428_1:
    heif_transfer_characteristics = 17;
pub const heif_transfer_characteristics_heif_transfer_characteristic_ITU_R_BT_2100_0_HLG:
    heif_transfer_characteristics = 18;
pub type heif_transfer_characteristics = libc::c_uint;
pub const heif_matrix_coefficients_heif_matrix_coefficients_RGB_GBR: heif_matrix_coefficients = 0;
#[doc = " TODO: or 709-6 according to h.273"]
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_709_5:
    heif_matrix_coefficients = 1;
pub const heif_matrix_coefficients_heif_matrix_coefficients_unspecified: heif_matrix_coefficients =
    2;
pub const heif_matrix_coefficients_heif_matrix_coefficients_US_FCC_T47: heif_matrix_coefficients =
    4;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_470_6_System_B_G:
    heif_matrix_coefficients = 5;
#[doc = " TODO: or 601-7 according to h.273"]
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_601_6:
    heif_matrix_coefficients = 6;
pub const heif_matrix_coefficients_heif_matrix_coefficients_SMPTE_240M: heif_matrix_coefficients =
    7;
pub const heif_matrix_coefficients_heif_matrix_coefficients_YCgCo: heif_matrix_coefficients = 8;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_2020_2_non_constant_luminance : heif_matrix_coefficients = 9 ;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ITU_R_BT_2020_2_constant_luminance:
    heif_matrix_coefficients = 10;
pub const heif_matrix_coefficients_heif_matrix_coefficients_SMPTE_ST_2085:
    heif_matrix_coefficients = 11;
pub const heif_matrix_coefficients_heif_matrix_coefficients_chromaticity_derived_non_constant_luminance : heif_matrix_coefficients = 12 ;
pub const heif_matrix_coefficients_heif_matrix_coefficients_chromaticity_derived_constant_luminance : heif_matrix_coefficients = 13 ;
pub const heif_matrix_coefficients_heif_matrix_coefficients_ICtCp: heif_matrix_coefficients = 14;
pub type heif_matrix_coefficients = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_color_profile_nclx {
    #[doc = " === version 1 fields"]
    pub version: u8,
    pub color_primaries: heif_color_primaries,
    pub transfer_characteristics: heif_transfer_characteristics,
    pub matrix_coefficients: heif_matrix_coefficients,
    pub full_range_flag: u8,
    #[doc = " --- decoded values (not used when saving nclx)"]
    pub color_primary_red_x: f32,
    #[doc = " --- decoded values (not used when saving nclx)"]
    pub color_primary_red_y: f32,
    pub color_primary_green_x: f32,
    pub color_primary_green_y: f32,
    pub color_primary_blue_x: f32,
    pub color_primary_blue_y: f32,
    pub color_primary_white_x: f32,
    pub color_primary_white_y: f32,
}
#[test]
fn bindgen_test_layout_heif_color_profile_nclx() {
    const UNINIT: ::std::mem::MaybeUninit<heif_color_profile_nclx> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_color_profile_nclx>(),
        52usize,
        concat!("Size of: ", stringify!(heif_color_profile_nclx))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_color_profile_nclx>(),
        4usize,
        concat!("Alignment of ", stringify!(heif_color_profile_nclx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer_characteristics) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(transfer_characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix_coefficients) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(matrix_coefficients)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_range_flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(full_range_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_red_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_red_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_red_y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_red_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_green_x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_green_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_green_y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_green_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_blue_x) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_blue_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_blue_y) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_blue_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_white_x) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_white_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primary_white_y) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_profile_nclx),
            "::",
            stringify!(color_primary_white_y)
        )
    );
}
extern "C" {
    pub fn heif_nclx_color_profile_set_color_primaries(
        nclx: *mut heif_color_profile_nclx,
        cp: u16,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_nclx_color_profile_set_transfer_characteristics(
        nclx: *mut heif_color_profile_nclx,
        transfer_characteristics: u16,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_nclx_color_profile_set_matrix_coefficients(
        nclx: *mut heif_color_profile_nclx,
        matrix_coefficients: u16,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Returns 'heif_error_Color_profile_does_not_exist' when there is no NCLX profile.\n TODO: This function does currently not return an NCLX profile if it is stored in the image bitstream.\n       Only NCLX profiles stored as colr boxes are returned. This may change in the future."]
    pub fn heif_image_handle_get_nclx_color_profile(
        handle: *const heif_image_handle,
        out_data: *mut *mut heif_color_profile_nclx,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Returned color profile has 'version' field set to the maximum allowed.\n Do not fill values for higher versions as these might be outside the allocated structure size.\n May return NULL."]
    pub fn heif_nclx_color_profile_alloc() -> *mut heif_color_profile_nclx;
}
extern "C" {
    pub fn heif_nclx_color_profile_free(nclx_profile: *mut heif_color_profile_nclx);
}
extern "C" {
    pub fn heif_image_get_color_profile_type(image: *const heif_image) -> heif_color_profile_type;
}
extern "C" {
    pub fn heif_image_get_raw_color_profile_size(image: *const heif_image) -> usize;
}
extern "C" {
    pub fn heif_image_get_raw_color_profile(
        image: *const heif_image,
        out_data: *mut libc::c_void,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_get_nclx_color_profile(
        image: *const heif_image,
        out_data: *mut *mut heif_color_profile_nclx,
    ) -> heif_error;
}
#[doc = "  heif_item_property_unknown = -1,"]
pub const heif_item_property_type_heif_item_property_type_invalid: heif_item_property_type = 0;
#[doc = "  heif_item_property_unknown = -1,"]
pub const heif_item_property_type_heif_item_property_type_user_description:
    heif_item_property_type = 1969513843;
#[doc = "  heif_item_property_unknown = -1,"]
pub const heif_item_property_type_heif_item_property_type_transform_mirror:
    heif_item_property_type = 1768778098;
#[doc = "  heif_item_property_unknown = -1,"]
pub const heif_item_property_type_heif_item_property_type_transform_rotation:
    heif_item_property_type = 1769107316;
#[doc = "  heif_item_property_unknown = -1,"]
pub const heif_item_property_type_heif_item_property_type_transform_crop: heif_item_property_type =
    1668047216;
#[doc = "  heif_item_property_unknown = -1,"]
pub const heif_item_property_type_heif_item_property_type_image_size: heif_item_property_type =
    1769173093;
#[doc = " ------------------------- item properties -------------------------"]
pub type heif_item_property_type = libc::c_uint;
extern "C" {
    #[doc = " Get the heif_property_id for a heif_item_id.\n You may specify which property 'type' you want to receive.\n If you specify 'heif_item_property_type_invalid', all properties associated to that item are returned.\n The number of properties is returned, which are not more than 'count' if (out_list != nullptr).\n By setting out_list==nullptr, you can query the number of properties, 'count' is ignored."]
    pub fn heif_item_get_properties_of_type(
        context: *const heif_context,
        id: heif_item_id,
        type_: heif_item_property_type,
        out_list: *mut heif_property_id,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns all transformative properties in the correct order.\n This includes \"irot\", \"imir\", \"clap\".\n The number of properties is returned, which are not more than 'count' if (out_list != nullptr).\n By setting out_list==nullptr, you can query the number of properties, 'count' is ignored."]
    pub fn heif_item_get_transformation_properties(
        context: *const heif_context,
        id: heif_item_id,
        out_list: *mut heif_property_id,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_item_get_property_type(
        context: *const heif_context,
        id: heif_item_id,
        property_id: heif_property_id,
    ) -> heif_item_property_type;
}
#[doc = " The strings are managed by libheif. They will be deleted in heif_property_user_description_release()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_property_user_description {
    pub version: libc::c_int,
    #[doc = " version 1"]
    pub lang: *const libc::c_char,
    pub name: *const libc::c_char,
    pub description: *const libc::c_char,
    pub tags: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_heif_property_user_description() {
    const UNINIT: ::std::mem::MaybeUninit<heif_property_user_description> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_property_user_description>(),
        40usize,
        concat!("Size of: ", stringify!(heif_property_user_description))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_property_user_description>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_property_user_description))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_property_user_description),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lang) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_property_user_description),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_property_user_description),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_property_user_description),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_property_user_description),
            "::",
            stringify!(tags)
        )
    );
}
extern "C" {
    #[doc = " Get the \"udes\" user description property content.\n Undefined strings are returned as empty strings."]
    pub fn heif_item_get_property_user_description(
        context: *const heif_context,
        itemId: heif_item_id,
        propertyId: heif_property_id,
        out: *mut *mut heif_property_user_description,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Add a \"udes\" user description property to the item.\n If any string pointers are NULL, an empty string will be used instead."]
    pub fn heif_item_add_property_user_description(
        context: *const heif_context,
        itemId: heif_item_id,
        description: *const heif_property_user_description,
        out_propertyId: *mut heif_property_id,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Release all strings and the object itself.\n Only call for objects that you received from heif_item_get_property_user_description()."]
    pub fn heif_property_user_description_release(arg1: *mut heif_property_user_description);
}
#[doc = " flip image vertically"]
pub const heif_transform_mirror_direction_heif_transform_mirror_direction_vertical:
    heif_transform_mirror_direction = 0;
#[doc = " flip image horizontally"]
pub const heif_transform_mirror_direction_heif_transform_mirror_direction_horizontal:
    heif_transform_mirror_direction = 1;
pub type heif_transform_mirror_direction = libc::c_uint;
extern "C" {
    pub fn heif_item_get_property_transform_mirror(
        context: *const heif_context,
        itemId: heif_item_id,
        propertyId: heif_property_id,
    ) -> heif_transform_mirror_direction;
}
extern "C" {
    #[doc = " Returns only 0, 90, 180, or 270 angle values.\n Returns -1 in case of error (but it will only return an error in case of wrong usage)."]
    pub fn heif_item_get_property_transform_rotation_ccw(
        context: *const heif_context,
        itemId: heif_item_id,
        propertyId: heif_property_id,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the number of pixels that should be removed from the four edges.\n Because of the way this data is stored, you have to pass the image size at the moment of the crop operation\n to compute the cropped border sizes."]
    pub fn heif_item_get_property_transform_crop_borders(
        context: *const heif_context,
        itemId: heif_item_id,
        propertyId: heif_property_id,
        image_width: libc::c_int,
        image_height: libc::c_int,
        left: *mut libc::c_int,
        top: *mut libc::c_int,
        right: *mut libc::c_int,
        bottom: *mut libc::c_int,
    );
}
pub const heif_compression_format_heif_compression_undefined: heif_compression_format = 0;
pub const heif_compression_format_heif_compression_HEVC: heif_compression_format = 1;
pub const heif_compression_format_heif_compression_AVC: heif_compression_format = 2;
pub const heif_compression_format_heif_compression_JPEG: heif_compression_format = 3;
pub const heif_compression_format_heif_compression_AV1: heif_compression_format = 4;
pub const heif_compression_format_heif_compression_VVC: heif_compression_format = 5;
pub const heif_compression_format_heif_compression_EVC: heif_compression_format = 6;
#[doc = " ISO/IEC 15444-16:2021"]
pub const heif_compression_format_heif_compression_JPEG2000: heif_compression_format = 7;
#[doc = " ISO/IEC 23001-17:2023"]
pub const heif_compression_format_heif_compression_uncompressed: heif_compression_format = 8;
#[doc = " Planar RGB images are specified as heif_colorspace_RGB / heif_chroma_444."]
pub type heif_compression_format = libc::c_uint;
pub const heif_chroma_heif_chroma_undefined: heif_chroma = 99;
pub const heif_chroma_heif_chroma_monochrome: heif_chroma = 0;
pub const heif_chroma_heif_chroma_420: heif_chroma = 1;
pub const heif_chroma_heif_chroma_422: heif_chroma = 2;
pub const heif_chroma_heif_chroma_444: heif_chroma = 3;
pub const heif_chroma_heif_chroma_interleaved_RGB: heif_chroma = 10;
pub const heif_chroma_heif_chroma_interleaved_RGBA: heif_chroma = 11;
#[doc = " HDR, big endian."]
pub const heif_chroma_heif_chroma_interleaved_RRGGBB_BE: heif_chroma = 12;
#[doc = " HDR, big endian."]
pub const heif_chroma_heif_chroma_interleaved_RRGGBBAA_BE: heif_chroma = 13;
#[doc = " HDR, little endian."]
pub const heif_chroma_heif_chroma_interleaved_RRGGBB_LE: heif_chroma = 14;
#[doc = " HDR, little endian."]
pub const heif_chroma_heif_chroma_interleaved_RRGGBBAA_LE: heif_chroma = 15;
pub type heif_chroma = libc::c_uint;
pub const heif_colorspace_heif_colorspace_undefined: heif_colorspace = 99;
#[doc = " heif_colorspace_YCbCr should be used with one of these heif_chroma values:\n * heif_chroma_444\n * heif_chroma_422\n * heif_chroma_420"]
pub const heif_colorspace_heif_colorspace_YCbCr: heif_colorspace = 0;
#[doc = " heif_colorspace_RGB should be used with one of these heif_chroma values:\n * heif_chroma_444 (for planar RGB)\n * heif_chroma_interleaved_RGB\n * heif_chroma_interleaved_RGBA\n * heif_chroma_interleaved_RRGGBB_BE\n * heif_chroma_interleaved_RRGGBBAA_BE\n * heif_chroma_interleaved_RRGGBB_LE\n * heif_chroma_interleaved_RRGGBBAA_LE"]
pub const heif_colorspace_heif_colorspace_RGB: heif_colorspace = 1;
#[doc = " heif_colorspace_monochrome should only be used with heif_chroma = heif_chroma_monochrome"]
pub const heif_colorspace_heif_colorspace_monochrome: heif_colorspace = 2;
pub type heif_colorspace = libc::c_uint;
pub const heif_channel_heif_channel_Y: heif_channel = 0;
pub const heif_channel_heif_channel_Cb: heif_channel = 1;
pub const heif_channel_heif_channel_Cr: heif_channel = 2;
pub const heif_channel_heif_channel_R: heif_channel = 3;
pub const heif_channel_heif_channel_G: heif_channel = 4;
pub const heif_channel_heif_channel_B: heif_channel = 5;
pub const heif_channel_heif_channel_Alpha: heif_channel = 6;
pub const heif_channel_heif_channel_interleaved: heif_channel = 10;
pub type heif_channel = libc::c_uint;
pub const heif_progress_step_heif_progress_step_total: heif_progress_step = 0;
pub const heif_progress_step_heif_progress_step_load_tile: heif_progress_step = 1;
pub type heif_progress_step = libc::c_uint;
pub const heif_chroma_downsampling_algorithm_heif_chroma_downsampling_nearest_neighbor:
    heif_chroma_downsampling_algorithm = 1;
pub const heif_chroma_downsampling_algorithm_heif_chroma_downsampling_average:
    heif_chroma_downsampling_algorithm = 2;
#[doc = " Combine with 'heif_chroma_upsampling_bilinear' for best quality.\n Makes edges look sharper when using YUV 420 with bilinear chroma upsampling."]
pub const heif_chroma_downsampling_algorithm_heif_chroma_downsampling_sharp_yuv:
    heif_chroma_downsampling_algorithm = 3;
pub type heif_chroma_downsampling_algorithm = libc::c_uint;
pub const heif_chroma_upsampling_algorithm_heif_chroma_upsampling_nearest_neighbor:
    heif_chroma_upsampling_algorithm = 1;
pub const heif_chroma_upsampling_algorithm_heif_chroma_upsampling_bilinear:
    heif_chroma_upsampling_algorithm = 2;
pub type heif_chroma_upsampling_algorithm = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_color_conversion_options {
    pub version: u8,
    #[doc = " --- version 1 options"]
    pub preferred_chroma_downsampling_algorithm: heif_chroma_downsampling_algorithm,
    pub preferred_chroma_upsampling_algorithm: heif_chroma_upsampling_algorithm,
    #[doc = " When set to 'false', libheif may also use a different algorithm if the preferred one is not available."]
    pub only_use_preferred_chroma_algorithm: u8,
}
#[test]
fn bindgen_test_layout_heif_color_conversion_options() {
    const UNINIT: ::std::mem::MaybeUninit<heif_color_conversion_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_color_conversion_options>(),
        16usize,
        concat!("Size of: ", stringify!(heif_color_conversion_options))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_color_conversion_options>(),
        4usize,
        concat!("Alignment of ", stringify!(heif_color_conversion_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_conversion_options),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).preferred_chroma_downsampling_algorithm) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_conversion_options),
            "::",
            stringify!(preferred_chroma_downsampling_algorithm)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).preferred_chroma_upsampling_algorithm) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_conversion_options),
            "::",
            stringify!(preferred_chroma_upsampling_algorithm)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).only_use_preferred_chroma_algorithm) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_color_conversion_options),
            "::",
            stringify!(only_use_preferred_chroma_algorithm)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoding_options {
    pub version: u8,
    #[doc = " Ignore geometric transformations like cropping, rotation, mirroring.\n Default: false (do not ignore)."]
    pub ignore_transformations: u8,
    pub start_progress: ::std::option::Option<
        unsafe extern "C" fn(
            step: heif_progress_step,
            max_progress: libc::c_int,
            progress_user_data: *mut libc::c_void,
        ),
    >,
    pub on_progress: ::std::option::Option<
        unsafe extern "C" fn(
            step: heif_progress_step,
            progress: libc::c_int,
            progress_user_data: *mut libc::c_void,
        ),
    >,
    pub end_progress: ::std::option::Option<
        unsafe extern "C" fn(step: heif_progress_step, progress_user_data: *mut libc::c_void),
    >,
    pub progress_user_data: *mut libc::c_void,
    #[doc = " version 2 options"]
    pub convert_hdr_to_8bit: u8,
    #[doc = " When enabled, an error is returned for invalid input. Otherwise, it will try its best and\n add decoding warnings to the decoded heif_image. Default is non-strict."]
    pub strict_decoding: u8,
    #[doc = " name_id of the decoder to use for the decoding.\n If set to NULL (default), the highest priority decoder is chosen.\n The priority is defined in the plugin."]
    pub decoder_id: *const libc::c_char,
    #[doc = " version 5 options"]
    pub color_conversion_options: heif_color_conversion_options,
}
#[test]
fn bindgen_test_layout_heif_decoding_options() {
    const UNINIT: ::std::mem::MaybeUninit<heif_decoding_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_decoding_options>(),
        72usize,
        concat!("Size of: ", stringify!(heif_decoding_options))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_decoding_options>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_decoding_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ignore_transformations) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(ignore_transformations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_progress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(start_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_progress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(on_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_progress) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(end_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress_user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(progress_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).convert_hdr_to_8bit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(convert_hdr_to_8bit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strict_decoding) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(strict_decoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoder_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(decoder_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_conversion_options) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoding_options),
            "::",
            stringify!(color_conversion_options)
        )
    );
}
extern "C" {
    #[doc = " Allocate decoding options and fill with default values.\n Note: you should always get the decoding options through this function since the\n option structure may grow in size in future versions."]
    pub fn heif_decoding_options_alloc() -> *mut heif_decoding_options;
}
extern "C" {
    pub fn heif_decoding_options_free(arg1: *mut heif_decoding_options);
}
extern "C" {
    #[doc = " Decode an heif_image_handle into the actual pixel image and also carry out\n all geometric transformations specified in the HEIF file (rotation, cropping, mirroring).\n\n If colorspace or chroma is set to heif_colorspace_undefined or heif_chroma_undefined,\n respectively, the original colorspace is taken.\n Decoding options may be NULL. If you want to supply options, always use\n heif_decoding_options_alloc() to get the structure."]
    pub fn heif_decode_image(
        in_handle: *const heif_image_handle,
        out_img: *mut *mut heif_image,
        colorspace: heif_colorspace,
        chroma: heif_chroma,
        options: *const heif_decoding_options,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Get the colorspace format of the image."]
    pub fn heif_image_get_colorspace(arg1: *const heif_image) -> heif_colorspace;
}
extern "C" {
    #[doc = " Get the chroma format of the image."]
    pub fn heif_image_get_chroma_format(arg1: *const heif_image) -> heif_chroma;
}
extern "C" {
    #[doc = " Get width of the given image channel in pixels. Returns -1 if a non-existing\n channel was given."]
    pub fn heif_image_get_width(arg1: *const heif_image, channel: heif_channel) -> libc::c_int;
}
extern "C" {
    #[doc = " Get height of the given image channel in pixels. Returns -1 if a non-existing\n channel was given."]
    pub fn heif_image_get_height(arg1: *const heif_image, channel: heif_channel) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the width of the main channel (Y in YCbCr, or any in RGB)."]
    pub fn heif_image_get_primary_width(arg1: *const heif_image) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_get_primary_height(arg1: *const heif_image) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_crop(
        img: *mut heif_image,
        left: libc::c_int,
        right: libc::c_int,
        top: libc::c_int,
        bottom: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Get the number of bits per pixel in the given image channel. Returns -1 if\n a non-existing channel was given.\n Note that the number of bits per pixel may be different for each color channel.\n This function returns the number of bits used for storage of each pixel.\n Especially for HDR images, this is probably not what you want. Have a look at\n heif_image_get_bits_per_pixel_range() instead."]
    pub fn heif_image_get_bits_per_pixel(
        arg1: *const heif_image,
        channel: heif_channel,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of bits per pixel in the given image channel. This function returns\n the number of bits used for representing the pixel value, which might be smaller\n than the number of bits used in memory.\n For example, in 12bit HDR images, this function returns '12', while still 16 bits\n are reserved for storage. For interleaved RGBA with 12 bit, this function also returns\n '12', not '48' or '64' (heif_image_get_bits_per_pixel returns 64 in this case)."]
    pub fn heif_image_get_bits_per_pixel_range(
        arg1: *const heif_image,
        channel: heif_channel,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_has_channel(arg1: *const heif_image, channel: heif_channel) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a pointer to the actual pixel data.\n The 'out_stride' is returned as \"bytes per line\".\n When out_stride is NULL, no value will be written.\n Returns NULL if a non-existing channel was given."]
    pub fn heif_image_get_plane_readonly(
        arg1: *const heif_image,
        channel: heif_channel,
        out_stride: *mut libc::c_int,
    ) -> *const u8;
}
extern "C" {
    pub fn heif_image_get_plane(
        arg1: *mut heif_image,
        channel: heif_channel,
        out_stride: *mut libc::c_int,
    ) -> *mut u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_scaling_options {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Currently, heif_scaling_options is not defined yet. Pass a NULL pointer."]
    pub fn heif_image_scale_image(
        input: *const heif_image,
        output: *mut *mut heif_image,
        width: libc::c_int,
        height: libc::c_int,
        options: *const heif_scaling_options,
    ) -> heif_error;
}
extern "C" {
    #[doc = " The color profile is not attached to the image handle because we might need it\n for color space transform and encoding."]
    pub fn heif_image_set_raw_color_profile(
        image: *mut heif_image,
        profile_type_fourcc_string: *const libc::c_char,
        profile_data: *const libc::c_void,
        profile_size: usize,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_set_nclx_color_profile(
        image: *mut heif_image,
        color_profile: *const heif_color_profile_nclx,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Fills the image decoding warnings into the provided 'out_warnings' array.\n The size of the array has to be provided in max_output_buffer_entries.\n If max_output_buffer_entries==0, the number of decoder warnings is returned.\n The function fills the warnings into the provided buffer, starting with 'first_warning_idx'.\n It returns the number of warnings filled into the buffer.\n Note: you can iterate through all warnings by using 'max_output_buffer_entries=1' and iterate 'first_warning_idx'."]
    pub fn heif_image_get_decoding_warnings(
        image: *mut heif_image,
        first_warning_idx: libc::c_int,
        out_warnings: *mut heif_error,
        max_output_buffer_entries: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " This function is only for decoder plugin implementors."]
    pub fn heif_image_add_decoding_warning(image: *mut heif_image, err: heif_error);
}
extern "C" {
    #[doc = " Release heif_image."]
    pub fn heif_image_release(arg1: *const heif_image);
}
#[doc = " Note: a value of 0 for any of these values indicates that the value is undefined.\n The unit of these values is Candelas per square meter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_content_light_level {
    pub max_content_light_level: u16,
    pub max_pic_average_light_level: u16,
}
#[test]
fn bindgen_test_layout_heif_content_light_level() {
    const UNINIT: ::std::mem::MaybeUninit<heif_content_light_level> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_content_light_level>(),
        4usize,
        concat!("Size of: ", stringify!(heif_content_light_level))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_content_light_level>(),
        2usize,
        concat!("Alignment of ", stringify!(heif_content_light_level))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_content_light_level),
            "::",
            stringify!(max_content_light_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_pic_average_light_level) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_content_light_level),
            "::",
            stringify!(max_pic_average_light_level)
        )
    );
}
extern "C" {
    pub fn heif_image_has_content_light_level(arg1: *const heif_image) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_get_content_light_level(
        arg1: *const heif_image,
        out: *mut heif_content_light_level,
    );
}
extern "C" {
    pub fn heif_image_set_content_light_level(
        arg1: *const heif_image,
        in_: *const heif_content_light_level,
    );
}
#[doc = " Note: color coordinates are defined according to the CIE 1931 definition of x as specified in ISO 11664-1 (see also ISO 11664-3 and CIE 15)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_mastering_display_colour_volume {
    pub display_primaries_x: [u16; 3usize],
    pub display_primaries_y: [u16; 3usize],
    pub white_point_x: u16,
    pub white_point_y: u16,
    pub max_display_mastering_luminance: u32,
    pub min_display_mastering_luminance: u32,
}
#[test]
fn bindgen_test_layout_heif_mastering_display_colour_volume() {
    const UNINIT: ::std::mem::MaybeUninit<heif_mastering_display_colour_volume> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_mastering_display_colour_volume>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(heif_mastering_display_colour_volume)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<heif_mastering_display_colour_volume>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(heif_mastering_display_colour_volume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_primaries_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_mastering_display_colour_volume),
            "::",
            stringify!(display_primaries_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_primaries_y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_mastering_display_colour_volume),
            "::",
            stringify!(display_primaries_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_mastering_display_colour_volume),
            "::",
            stringify!(white_point_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_mastering_display_colour_volume),
            "::",
            stringify!(white_point_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_mastering_display_colour_volume),
            "::",
            stringify!(max_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_mastering_display_colour_volume),
            "::",
            stringify!(min_display_mastering_luminance)
        )
    );
}
#[doc = " The units for max_display_mastering_luminance and min_display_mastering_luminance is Candelas per square meter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoded_mastering_display_colour_volume {
    pub display_primaries_x: [f32; 3usize],
    pub display_primaries_y: [f32; 3usize],
    pub white_point_x: f32,
    pub white_point_y: f32,
    pub max_display_mastering_luminance: f64,
    pub min_display_mastering_luminance: f64,
}
#[test]
fn bindgen_test_layout_heif_decoded_mastering_display_colour_volume() {
    const UNINIT: ::std::mem::MaybeUninit<heif_decoded_mastering_display_colour_volume> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_decoded_mastering_display_colour_volume>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(heif_decoded_mastering_display_colour_volume)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<heif_decoded_mastering_display_colour_volume>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(heif_decoded_mastering_display_colour_volume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_primaries_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoded_mastering_display_colour_volume),
            "::",
            stringify!(display_primaries_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_primaries_y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoded_mastering_display_colour_volume),
            "::",
            stringify!(display_primaries_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point_x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoded_mastering_display_colour_volume),
            "::",
            stringify!(white_point_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point_y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoded_mastering_display_colour_volume),
            "::",
            stringify!(white_point_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoded_mastering_display_colour_volume),
            "::",
            stringify!(max_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_decoded_mastering_display_colour_volume),
            "::",
            stringify!(min_display_mastering_luminance)
        )
    );
}
extern "C" {
    pub fn heif_image_has_mastering_display_colour_volume(arg1: *const heif_image) -> libc::c_int;
}
extern "C" {
    pub fn heif_image_get_mastering_display_colour_volume(
        arg1: *const heif_image,
        out: *mut heif_mastering_display_colour_volume,
    );
}
extern "C" {
    pub fn heif_image_set_mastering_display_colour_volume(
        arg1: *const heif_image,
        in_: *const heif_mastering_display_colour_volume,
    );
}
extern "C" {
    #[doc = " Converts the internal numeric representation of heif_mastering_display_colour_volume to the\n normalized values, collected in heif_decoded_mastering_display_colour_volume.\n Values that are out-of-range are decoded to 0, indicating an undefined value (as specified in ISO/IEC 23008-2)."]
    pub fn heif_mastering_display_colour_volume_decode(
        in_: *const heif_mastering_display_colour_volume,
        out: *mut heif_decoded_mastering_display_colour_volume,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_image_get_pixel_aspect_ratio(
        arg1: *const heif_image,
        aspect_h: *mut u32,
        aspect_v: *mut u32,
    );
}
extern "C" {
    pub fn heif_image_set_pixel_aspect_ratio(arg1: *mut heif_image, aspect_h: u32, aspect_v: u32);
}
extern "C" {
    #[doc = " ====================================================================================================\n  Encoding API"]
    pub fn heif_context_write_to_file(
        arg1: *mut heif_context,
        filename: *const libc::c_char,
    ) -> heif_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_writer {
    #[doc = " API version supported by this writer"]
    pub writer_api_version: libc::c_int,
    #[doc = " TODO: why do we need this parameter?"]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut heif_context,
            data: *const libc::c_void,
            size: usize,
            userdata: *mut libc::c_void,
        ) -> heif_error,
    >,
}
#[test]
fn bindgen_test_layout_heif_writer() {
    const UNINIT: ::std::mem::MaybeUninit<heif_writer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_writer>(),
        16usize,
        concat!("Size of: ", stringify!(heif_writer))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_writer>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_writer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writer_api_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_writer),
            "::",
            stringify!(writer_api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_writer),
            "::",
            stringify!(write)
        )
    );
}
extern "C" {
    pub fn heif_context_write(
        arg1: *mut heif_context,
        writer: *mut heif_writer,
        userdata: *mut libc::c_void,
    ) -> heif_error;
}
#[doc = " The encoder used for actually encoding an image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder {
    _unused: [u8; 0],
}
#[doc = " A description of the encoder's capabilities and name."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder_descriptor {
    _unused: [u8; 0],
}
#[doc = " A configuration parameter of the encoder. Each encoder implementation may have a different\n set of parameters. For the most common settings (e.q. quality), special functions to set\n the parameters are provided."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder_parameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoder_descriptor {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get a list of available decoders. You can filter the encoders by compression format.\n Use format_filter==heif_compression_undefined to get all available decoders.\n The returned list of decoders is sorted by their priority (which is a plugin property).\n The number of decoders is returned, which are not more than 'count' if (out_decoders != nullptr).\n By setting out_decoders==nullptr, you can query the number of decoders, 'count' is ignored."]
    pub fn heif_get_decoder_descriptors(
        format_filter: heif_compression_format,
        out_decoders: *mut *const heif_decoder_descriptor,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a long, descriptive name of the decoder (including version information)."]
    pub fn heif_decoder_descriptor_get_name(
        arg1: *const heif_decoder_descriptor,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return a short, symbolic name for identifying the decoder.\n This name should stay constant over different decoder versions.\n Note: the returned ID may be NULL for old plugins that don't support this yet."]
    pub fn heif_decoder_descriptor_get_id_name(
        arg1: *const heif_decoder_descriptor,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " DEPRECATED: use heif_get_encoder_descriptors() instead.\n Get a list of available encoders. You can filter the encoders by compression format and name.\n Use format_filter==heif_compression_undefined and name_filter==NULL as wildcards.\n The returned list of encoders is sorted by their priority (which is a plugin property).\n The number of encoders is returned, which are not more than 'count' if (out_encoders != nullptr).\n By setting out_encoders==nullptr, you can query the number of encoders, 'count' is ignored.\n Note: to get the actual encoder from the descriptors returned here, use heif_context_get_encoder()."]
    pub fn heif_context_get_encoder_descriptors(
        arg1: *mut heif_context,
        format_filter: heif_compression_format,
        name_filter: *const libc::c_char,
        out_encoders: *mut *const heif_encoder_descriptor,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a list of available encoders. You can filter the encoders by compression format and name.\n Use format_filter==heif_compression_undefined and name_filter==NULL as wildcards.\n The returned list of encoders is sorted by their priority (which is a plugin property).\n The number of encoders is returned, which are not more than 'count' if (out_encoders != nullptr).\n By setting out_encoders==nullptr, you can query the number of encoders, 'count' is ignored.\n Note: to get the actual encoder from the descriptors returned here, use heif_context_get_encoder()."]
    pub fn heif_get_encoder_descriptors(
        format_filter: heif_compression_format,
        name_filter: *const libc::c_char,
        out_encoders: *mut *const heif_encoder_descriptor,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return a long, descriptive name of the encoder (including version information)."]
    pub fn heif_encoder_descriptor_get_name(
        arg1: *const heif_encoder_descriptor,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return a short, symbolic name for identifying the encoder.\n This name should stay constant over different encoder versions."]
    pub fn heif_encoder_descriptor_get_id_name(
        arg1: *const heif_encoder_descriptor,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn heif_encoder_descriptor_get_compression_format(
        arg1: *const heif_encoder_descriptor,
    ) -> heif_compression_format;
}
extern "C" {
    pub fn heif_encoder_descriptor_supports_lossy_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_encoder_descriptor_supports_lossless_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get an encoder instance that can be used to actually encode images from a descriptor."]
    pub fn heif_context_get_encoder(
        context: *mut heif_context,
        arg1: *const heif_encoder_descriptor,
        out_encoder: *mut *mut heif_encoder,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Quick check whether there is a decoder available for the given format.\n Note that the decoder still may not be able to decode all variants of that format.\n You will have to query that further (todo) or just try to decode and check the returned error."]
    pub fn heif_have_decoder_for_format(format: heif_compression_format) -> libc::c_int;
}
extern "C" {
    #[doc = " Quick check whether there is an enoder available for the given format.\n Note that the encoder may be limited to a certain subset of features (e.g. only 8 bit, only lossy).\n You will have to query the specific capabilities further."]
    pub fn heif_have_encoder_for_format(format: heif_compression_format) -> libc::c_int;
}
extern "C" {
    #[doc = " Get an encoder for the given compression format. If there are several encoder plugins\n for this format, the encoder with the highest plugin priority will be returned."]
    pub fn heif_context_get_encoder_for_format(
        context: *mut heif_context,
        format: heif_compression_format,
        arg1: *mut *mut heif_encoder,
    ) -> heif_error;
}
extern "C" {
    #[doc = " You have to release the encoder after use."]
    pub fn heif_encoder_release(arg1: *mut heif_encoder);
}
extern "C" {
    #[doc = " Get the encoder name from the encoder itself."]
    pub fn heif_encoder_get_name(arg1: *const heif_encoder) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Set a 'quality' factor (0-100). How this is mapped to actual encoding parameters is\n encoder dependent."]
    pub fn heif_encoder_set_lossy_quality(
        arg1: *mut heif_encoder,
        quality: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_lossless(arg1: *mut heif_encoder, enable: libc::c_int) -> heif_error;
}
extern "C" {
    #[doc = " level should be between 0 (= none) to 4 (= full)"]
    pub fn heif_encoder_set_logging_level(
        arg1: *mut heif_encoder,
        level: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Get a generic list of encoder parameters.\n Each encoder may define its own, additional set of parameters.\n You do not have to free the returned list."]
    pub fn heif_encoder_list_parameters(
        arg1: *mut heif_encoder,
    ) -> *const *const heif_encoder_parameter;
}
extern "C" {
    #[doc = " Return the parameter name."]
    pub fn heif_encoder_parameter_get_name(
        arg1: *const heif_encoder_parameter,
    ) -> *const libc::c_char;
}
pub const heif_encoder_parameter_type_heif_encoder_parameter_type_integer:
    heif_encoder_parameter_type = 1;
pub const heif_encoder_parameter_type_heif_encoder_parameter_type_boolean:
    heif_encoder_parameter_type = 2;
pub const heif_encoder_parameter_type_heif_encoder_parameter_type_string:
    heif_encoder_parameter_type = 3;
pub type heif_encoder_parameter_type = libc::c_uint;
extern "C" {
    #[doc = " Return the parameter type."]
    pub fn heif_encoder_parameter_get_type(
        arg1: *const heif_encoder_parameter,
    ) -> heif_encoder_parameter_type;
}
extern "C" {
    #[doc = " DEPRECATED. Use heif_encoder_parameter_get_valid_integer_values() instead."]
    pub fn heif_encoder_parameter_get_valid_integer_range(
        arg1: *const heif_encoder_parameter,
        have_minimum_maximum: *mut libc::c_int,
        minimum: *mut libc::c_int,
        maximum: *mut libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " If integer is limited by a range, have_minimum and/or have_maximum will be != 0 and *minimum, *maximum is set.\n If integer is limited by a fixed set of values, *num_valid_values will be >0 and *out_integer_array is set."]
    pub fn heif_encoder_parameter_get_valid_integer_values(
        arg1: *const heif_encoder_parameter,
        have_minimum: *mut libc::c_int,
        have_maximum: *mut libc::c_int,
        minimum: *mut libc::c_int,
        maximum: *mut libc::c_int,
        num_valid_values: *mut libc::c_int,
        out_integer_array: *mut *const libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_get_valid_string_values(
        arg1: *const heif_encoder_parameter,
        out_stringarray: *mut *const *const libc::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_parameter_integer(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_get_parameter_integer(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value: *mut libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_integer_valid_range(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        have_minimum_maximum: *mut libc::c_int,
        minimum: *mut libc::c_int,
        maximum: *mut libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_parameter_boolean(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_get_parameter_boolean(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value: *mut libc::c_int,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_set_parameter_string(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value: *const libc::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_get_parameter_string(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value: *mut libc::c_char,
        value_size: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " returns a NULL-terminated list of valid strings or NULL if all values are allowed"]
    pub fn heif_encoder_parameter_string_valid_values(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        out_stringarray: *mut *const *const libc::c_char,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_encoder_parameter_integer_valid_values(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        have_minimum: *mut libc::c_int,
        have_maximum: *mut libc::c_int,
        minimum: *mut libc::c_int,
        maximum: *mut libc::c_int,
        num_valid_values: *mut libc::c_int,
        out_integer_array: *mut *const libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Set a parameter of any type to the string value.\n Integer values are parsed from the string.\n Boolean values can be \"true\"/\"false\"/\"1\"/\"0\"\n\n x265 encoder specific note:\n When using the x265 encoder, you may pass any of its parameters by\n prefixing the parameter name with 'x265:'. Hence, to set the 'ctu' parameter,\n you will have to set 'x265:ctu' in libheif.\n Note that there is no checking for valid parameters when using the prefix."]
    pub fn heif_encoder_set_parameter(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value: *const libc::c_char,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Get the current value of a parameter of any type as a human readable string.\n The returned string is compatible with heif_encoder_set_parameter()."]
    pub fn heif_encoder_get_parameter(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
        value_ptr: *mut libc::c_char,
        value_size: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Query whether a specific parameter has a default value."]
    pub fn heif_encoder_has_default(
        arg1: *mut heif_encoder,
        parameter_name: *const libc::c_char,
    ) -> libc::c_int;
}
pub const heif_orientation_heif_orientation_normal: heif_orientation = 1;
pub const heif_orientation_heif_orientation_flip_horizontally: heif_orientation = 2;
pub const heif_orientation_heif_orientation_rotate_180: heif_orientation = 3;
pub const heif_orientation_heif_orientation_flip_vertically: heif_orientation = 4;
pub const heif_orientation_heif_orientation_rotate_90_cw_then_flip_horizontally: heif_orientation =
    5;
pub const heif_orientation_heif_orientation_rotate_90_cw: heif_orientation = 6;
pub const heif_orientation_heif_orientation_rotate_90_cw_then_flip_vertically: heif_orientation = 7;
pub const heif_orientation_heif_orientation_rotate_270_cw: heif_orientation = 8;
#[doc = " The orientation values are defined equal to the EXIF Orientation tag."]
pub type heif_orientation = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoding_options {
    pub version: u8,
    #[doc = " default: true"]
    pub save_alpha_channel: u8,
    #[doc = " DEPRECATED. This option is not required anymore. Its value will be ignored."]
    pub macOS_compatibility_workaround: u8,
    #[doc = " default: false"]
    pub save_two_colr_boxes_when_ICC_and_nclx_available: u8,
    #[doc = " Set this to the NCLX parameters to be used in the output image or set to NULL\n when the same parameters as in the input image should be used."]
    pub output_nclx_profile: *mut heif_color_profile_nclx,
    pub macOS_compatibility_workaround_no_nclx_profile: u8,
    #[doc = " libheif will generate irot/imir boxes to match these orientations"]
    pub image_orientation: heif_orientation,
    #[doc = " version 6 options"]
    pub color_conversion_options: heif_color_conversion_options,
}
#[test]
fn bindgen_test_layout_heif_encoding_options() {
    const UNINIT: ::std::mem::MaybeUninit<heif_encoding_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<heif_encoding_options>(),
        40usize,
        concat!("Size of: ", stringify!(heif_encoding_options))
    );
    assert_eq!(
        ::std::mem::align_of::<heif_encoding_options>(),
        8usize,
        concat!("Alignment of ", stringify!(heif_encoding_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).save_alpha_channel) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(save_alpha_channel)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).macOS_compatibility_workaround) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(macOS_compatibility_workaround)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).save_two_colr_boxes_when_ICC_and_nclx_available) as usize
                - ptr as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(save_two_colr_boxes_when_ICC_and_nclx_available)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_nclx_profile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(output_nclx_profile)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).macOS_compatibility_workaround_no_nclx_profile) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(macOS_compatibility_workaround_no_nclx_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).image_orientation) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(image_orientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_conversion_options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heif_encoding_options),
            "::",
            stringify!(color_conversion_options)
        )
    );
}
extern "C" {
    pub fn heif_encoding_options_alloc() -> *mut heif_encoding_options;
}
extern "C" {
    pub fn heif_encoding_options_free(arg1: *mut heif_encoding_options);
}
extern "C" {
    #[doc = " Compress the input image.\n Returns a handle to the coded image in 'out_image_handle' unless out_image_handle = NULL.\n 'options' should be NULL for now.\n The first image added to the context is also automatically set the primary image, but\n you can change the primary image later with heif_context_set_primary_image()."]
    pub fn heif_context_encode_image(
        arg1: *mut heif_context,
        image: *const heif_image,
        encoder: *mut heif_encoder,
        options: *const heif_encoding_options,
        out_image_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_context_set_primary_image(
        arg1: *mut heif_context,
        image_handle: *mut heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Encode the 'image' as a scaled down thumbnail image.\n The image is scaled down to fit into a square area of width 'bbox_size'.\n If the input image is already so small that it fits into this bounding box, no thumbnail\n image is encoded and NULL is returned in 'out_thumb_image_handle'.\n No error is returned in this case.\n The encoded thumbnail is automatically assigned to the 'master_image_handle'. Hence, you\n do not have to call heif_context_assign_thumbnail()."]
    pub fn heif_context_encode_thumbnail(
        arg1: *mut heif_context,
        image: *const heif_image,
        master_image_handle: *const heif_image_handle,
        encoder: *mut heif_encoder,
        options: *const heif_encoding_options,
        bbox_size: libc::c_int,
        out_thumb_image_handle: *mut *mut heif_image_handle,
    ) -> heif_error;
}
pub const heif_metadata_compression_heif_metadata_compression_off: heif_metadata_compression = 0;
pub const heif_metadata_compression_heif_metadata_compression_auto: heif_metadata_compression = 1;
pub const heif_metadata_compression_heif_metadata_compression_deflate: heif_metadata_compression =
    2;
pub type heif_metadata_compression = libc::c_uint;
extern "C" {
    #[doc = " Assign 'thumbnail_image' as the thumbnail image of 'master_image'."]
    pub fn heif_context_assign_thumbnail(
        arg1: *mut heif_context,
        master_image: *const heif_image_handle,
        thumbnail_image: *const heif_image_handle,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Add EXIF metadata to an image."]
    pub fn heif_context_add_exif_metadata(
        arg1: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Add XMP metadata to an image."]
    pub fn heif_context_add_XMP_metadata(
        arg1: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " New version of heif_context_add_XMP_metadata() with data compression (experimental)."]
    pub fn heif_context_add_XMP_metadata2(
        arg1: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const libc::c_void,
        size: libc::c_int,
        compression: heif_metadata_compression,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Add generic, proprietary metadata to an image. You have to specify an 'item_type' that will\n identify your metadata. 'content_type' can be an additional type, or it can be NULL.\n For example, this function can be used to add IPTC metadata (IIM stream, not XMP) to an image.\n Although not standard, we propose to store IPTC data with item type=\"iptc\", content_type=NULL."]
    pub fn heif_context_add_generic_metadata(
        ctx: *mut heif_context,
        image_handle: *const heif_image_handle,
        data: *const libc::c_void,
        size: libc::c_int,
        item_type: *const libc::c_char,
        content_type: *const libc::c_char,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Create a new image of the specified resolution and colorspace.\n Note: no memory for the actual image data is reserved yet. You have to use\n heif_image_add_plane() to add the image planes required by your colorspace/chroma."]
    pub fn heif_image_create(
        width: libc::c_int,
        height: libc::c_int,
        colorspace: heif_colorspace,
        chroma: heif_chroma,
        out_image: *mut *mut heif_image,
    ) -> heif_error;
}
extern "C" {
    #[doc = " The indicated bit_depth corresponds to the bit depth per channel.\n I.e. for interleaved formats like RRGGBB, the bit_depth would be, e.g., 10 bit instead\n of 30 bits or 3*16=48 bits.\n For backward compatibility, one can also specify 24bits for RGB and 32bits for RGBA,\n instead of the preferred 8 bits."]
    pub fn heif_image_add_plane(
        image: *mut heif_image,
        channel: heif_channel,
        width: libc::c_int,
        height: libc::c_int,
        bit_depth: libc::c_int,
    ) -> heif_error;
}
extern "C" {
    #[doc = " Signal that the image is premultiplied by the alpha pixel values."]
    pub fn heif_image_set_premultiplied_alpha(
        image: *mut heif_image,
        is_premultiplied_alpha: libc::c_int,
    );
}
extern "C" {
    pub fn heif_image_is_premultiplied_alpha(image: *mut heif_image) -> libc::c_int;
}
extern "C" {
    #[doc = " This function extends the padding of the image so that it has at least the given physical size.\n The padding border is filled with the pixels along the right/bottom border.\n This function may be useful if you want to process the image, but have some external padding requirements.\n The image size will not be modified if it is already larger/equal than the given physical size.\n I.e. you cannot assume that after calling this function, the stride will be equal to min_physical_width."]
    pub fn heif_image_extend_padding_to_size(
        image: *mut heif_image,
        min_physical_width: libc::c_int,
        min_physical_height: libc::c_int,
    ) -> heif_error;
}
#[doc = " --- register plugins"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_decoder_plugin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_encoder_plugin {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " DEPRECATED. Use heif_register_decoder_plugin(const struct heif_decoder_plugin*) instead."]
    pub fn heif_register_decoder(
        heif: *mut heif_context,
        arg1: *const heif_decoder_plugin,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_register_decoder_plugin(arg1: *const heif_decoder_plugin) -> heif_error;
}
extern "C" {
    pub fn heif_register_encoder_plugin(arg1: *const heif_encoder_plugin) -> heif_error;
}
extern "C" {
    #[doc = " DEPRECATED, typo in function name"]
    pub fn heif_encoder_descriptor_supportes_lossy_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " DEPRECATED, typo in function name"]
    pub fn heif_encoder_descriptor_supportes_lossless_compression(
        arg1: *const heif_encoder_descriptor,
    ) -> libc::c_int;
}
#[doc = " See ISO/IEC 23008-12:2022 Section 6.10 \"Region items and region annotations\""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_region_item {
    _unused: [u8; 0],
}
pub const heif_region_type_heif_region_type_point: heif_region_type = 0;
pub const heif_region_type_heif_region_type_rectangle: heif_region_type = 1;
pub const heif_region_type_heif_region_type_ellipse: heif_region_type = 2;
pub const heif_region_type_heif_region_type_polygon: heif_region_type = 3;
#[doc = " TODO"]
pub const heif_region_type_heif_region_type_referenced_mask: heif_region_type = 4;
#[doc = " TODO"]
pub const heif_region_type_heif_region_type_inline_mask: heif_region_type = 5;
pub const heif_region_type_heif_region_type_polyline: heif_region_type = 6;
pub type heif_region_type = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heif_region {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " How many region items are attached to an image."]
    pub fn heif_image_handle_get_number_of_region_items(
        image_handle: *const heif_image_handle,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the region_item IDs assigned to an image.\n Returns the number of region items outputted."]
    pub fn heif_image_handle_get_list_of_region_item_ids(
        image_handle: *const heif_image_handle,
        region_item_ids_array: *mut heif_item_id,
        max_count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " You have to release the output heif_region_item with heif_region_item_release()."]
    pub fn heif_context_get_region_item(
        context: *const heif_context,
        region_item_id: heif_item_id,
        out: *mut *mut heif_region_item,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_item_get_id(arg1: *mut heif_region_item) -> heif_item_id;
}
extern "C" {
    pub fn heif_region_item_release(arg1: *mut heif_region_item);
}
extern "C" {
    #[doc = " The reference size specifies the coordinate space using for the region items.\n It is the size of the area of the encoded image prior to any transformations."]
    pub fn heif_region_item_get_reference_size(
        arg1: *mut heif_region_item,
        width: *mut u32,
        height: *mut u32,
    );
}
extern "C" {
    pub fn heif_region_item_get_number_of_regions(
        region_item: *const heif_region_item,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " You will have to release all returned heif_region objects with heif_region_release() or heif_region_release_many().\n 'out_regions' should point to an array of size 'max_count'.\n The function returns the number of regions filled into the 'out_regions' array."]
    pub fn heif_region_item_get_list_of_regions(
        region_item: *const heif_region_item,
        out_regions_array: *mut *mut heif_region,
        max_count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heif_region_release(region: *const heif_region);
}
extern "C" {
    pub fn heif_region_release_many(regions_array: *const *const heif_region, num: libc::c_int);
}
extern "C" {
    pub fn heif_region_get_type(region: *const heif_region) -> heif_region_type;
}
extern "C" {
    #[doc = " When querying the region geometry, there is a version without and a version with \"_transformed\" suffix.\n The version without returns the coordinates in the reference coordinate space.\n The version with \"_transformed\" suffix give the coordinates in pixels after all transformative properties have been applied."]
    pub fn heif_region_get_point(
        region: *const heif_region,
        x: *mut i32,
        y: *mut i32,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_point_transformed(
        region: *const heif_region,
        x: *mut f64,
        y: *mut f64,
        image_id: heif_item_id,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_rectangle(
        region: *const heif_region,
        x: *mut i32,
        y: *mut i32,
        width: *mut u32,
        height: *mut u32,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_rectangle_transformed(
        region: *const heif_region,
        x: *mut f64,
        y: *mut f64,
        width: *mut f64,
        height: *mut f64,
        image_id: heif_item_id,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_ellipse(
        region: *const heif_region,
        x: *mut i32,
        y: *mut i32,
        radius_x: *mut u32,
        radius_y: *mut u32,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_ellipse_transformed(
        region: *const heif_region,
        x: *mut f64,
        y: *mut f64,
        radius_x: *mut f64,
        radius_y: *mut f64,
        image_id: heif_item_id,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_polygon_num_points(region: *const heif_region) -> libc::c_int;
}
extern "C" {
    #[doc = " Point coordinates are stored in the output array 'pts'. This must have twice as many entries as there are points.\n Each point is stored as consecutive x and y positions."]
    pub fn heif_region_get_polygon_points(
        region: *const heif_region,
        out_pts_array: *mut i32,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_polygon_points_transformed(
        region: *const heif_region,
        out_pts_array: *mut f64,
        image_id: heif_item_id,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_polyline_num_points(region: *const heif_region) -> libc::c_int;
}
extern "C" {
    pub fn heif_region_get_polyline_points(
        region: *const heif_region,
        out_pts_array: *mut i32,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_get_polyline_points_transformed(
        region: *const heif_region,
        out_pts_array: *mut f64,
        image_id: heif_item_id,
    ) -> heif_error;
}
extern "C" {
    #[doc = " --- adding region items"]
    pub fn heif_image_handle_add_region_item(
        image_handle: *mut heif_image_handle,
        reference_width: u32,
        reference_height: u32,
        out_region_item: *mut *mut heif_region_item,
    ) -> heif_error;
}
extern "C" {
    #[doc = " When adding regions, there is an optional 'out_region' parameter.\n This is usually not needed. You may set it to NULL."]
    pub fn heif_region_item_add_region_point(
        arg1: *mut heif_region_item,
        x: i32,
        y: i32,
        out_region: *mut *mut heif_region,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_item_add_region_rectangle(
        arg1: *mut heif_region_item,
        x: i32,
        y: i32,
        width: u32,
        height: u32,
        out_region: *mut *mut heif_region,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_item_add_region_ellipse(
        arg1: *mut heif_region_item,
        x: i32,
        y: i32,
        radius_x: u32,
        radius_y: u32,
        out_region: *mut *mut heif_region,
    ) -> heif_error;
}
extern "C" {
    #[doc = " pts[] is an array of 2*nPoints, each pair representing x and y."]
    pub fn heif_region_item_add_region_polygon(
        arg1: *mut heif_region_item,
        pts_array: *const i32,
        nPoints: libc::c_int,
        out_region: *mut *mut heif_region,
    ) -> heif_error;
}
extern "C" {
    pub fn heif_region_item_add_region_polyline(
        arg1: *mut heif_region_item,
        pts_array: *const i32,
        nPoints: libc::c_int,
        out_region: *mut *mut heif_region,
    ) -> heif_error;
}
